#####  貪心演算法思路

我想說可以先假設所有節點到A的距離是無限大，然後用貪心演算法更新每個節點的最佳解，最後會求得B的最短路徑

##### 方式介紹



 A到X1 X2 X3 共有三條路徑 ，我假設A到X1 5單位 到X2 6單位 到X3 7單位 比較好思考 

這邊唯一可以確定到A的距離的是X1節點(也就是離A最短的預估節點) ，因為距離只有正的，如果不走A---X1這條路改走其他路(都比A----X1遠)一定會比5大，就不會是最短距離。

 其他兩個只能假設是6 跟7

 A是確定節點 確定最短路徑是5

然後預估跟X1接的節點的最短距離 分別是 17 18 19 (但都不確定 可能從X2 X3繞過來會比較快，理由如下)



#### ※為何要選尚未確定的節點中距離A最近的那個然後預估與它連接的節點，並把他標記成確定的呢?

因為貪心演算法的精神就是 :

持續尋找當下的最佳解，換句話說不能回頭，所以跟剛剛一樣，開始搜尋目前離A最近的節點(避免從其他節點繞路的問題，例如先搜尋X3然後經過一些步驟到達B，可是到X3的方式可能不只一種(沒有搜尋完誰知道)

EX:(A---X3) (A---X2---X5----X3) 

 因為A----X3>A----X2 這樣就有機會使(A---X3)不是a-->X3最短路徑 (Ex x2----x5----x3距離0.5之類的)

這麼一來剛剛計算出來的就不是最佳解(最佳解會是 A----X2----X5----X3-----..........----B 距離6.5+x3----....----B)

而不是剛剛的錯誤示範(A----X3----....------B 距離 7+x3---....---B)明顯不是最佳解

所以接著來看X2節點(確定離A最短是6，目前離A最近)



到X4 X5 X6分別是3 2 0.5 但是都是預估的

現在居然發現 A---X1---X4 這條路17單位，但是A----X2----X4 這條路只要9個單位，這也是貪心演算法的精神，先找到一個最佳解(17)，然後找下一個(9).....

這種情況的話要把X4從原本假設17變成9(剛剛發現的)



接著就用這種方式，先從尚未確定距離(已經確定就不用計算了)的節點找出離A最短的那個節點(能避免上面的理由)，然後標記那個點已經確定，接著掃描從那個點延伸出來的路徑，如果算出來的路徑比原本的還短(上面17>9這個例子)，該點假設的最短路徑就要更新，重複上述步驟直到點B被確定為止。

#### 遞迴解法

初步構想如下(使用虛擬碼表達)

void 求最小值(int 上個節點目前距離, int 上個節點編號,int 目前節點編號){

  如果目前節點編號為終點 就

{

​     更新最小值 Ex: 輸出的最小距離= min(上個節點目前距離+上個節點到這個節點距離,輸出的最小距離);

​     結束這個函數 (C++中可以return ;退出void函數)

}

當(還有沒掃過的節點)就{

​     求最小值(上個節點距離+上個節點到這個節點,目前節點編號,連接到這個節點的編號)

}

}